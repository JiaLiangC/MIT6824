1.了解 labrpc的结构
了解了之前的mapreduce lab1时候的任务流程，
todo: 画lab1 整体调用流程图

初始时大家的状态，有无leader 以及如何选出leader 
如何判断谁是leader


2.了解leader选举的步骤，列出流程图或者steps

leader 处理所有来自客户端的请求
每一个服务器一定处于三种状态之一 领导者 追随者 候选人
如果客户端和追随者通信将会被重定向给领导者


实现一个心跳机制来触发选举：
利用不带有任何日志条目的 AppendEntries RPC

流程 服务器第一次启动时所有服务器都初始化为 flower，等待leader的心跳来重置超时时间
如果某个 flower 超时到期后任然没有收到 心跳 就会变为 candidate (首先自增自己当前的任期，然后状态变为候选者)
触发选举。
然后他会给自己投票并且给集群中其他的机器发送  RequestVote RPC 请求。
候选人会一直处于候选状态 直到

它赢得了选举； (如何判定他赢得了选举)
另一台服务器赢得了选举；（如何得知）
一段时间后没有任何一台服务器赢得了选举 （如何得知）


赢得选举的条件
候选人在一个任期内收到了集群中大多数服务器的投票
在一个任期内，一台服务器最多能给一个候选人投票！先到先投的原则

1 一旦有候选人赢得了选举，它就会向其他服务器发送心跳信息来建立自己的领导地位。
（如果某台机器触发选举时，其他服务器任然收到了服务器的心跳呢？）
（投票的前提是该服务器没有收到心跳么？）

2 当一个候选人等待投票时可能会收到 心跳信息 （来自其他服务器发来的声明其为领导人的 AppendEntries RPC）
如果这个领导人的任期比候选人的当前任期要大，则认可其地位并且转换为flower， 如果小于则拒绝此次RPC并且继续保持候选人地位

3 如果多个候选人都获得相仿的选票数，没有人成为leader，此时所有的候选人都会超时，通过自增任期号后发起另一轮的RequestVote RPC 
来开始选举




AppendEntries 作用

RequestVote 作用
RequestVoteArgs 作用
RequestVoteReply 作用
Make()作用
AppendEntries 作用


任期号的更新发生在哪些情况下

AppendEntries 返回的term	当前的任期号，用于领导人更新自己的任期号，根据什么规则来更新领导人的任期号


raft 在哪里接收心跳
判断过期后触发选举
leader 多久向 flower 发出心跳
candidate 发出心跳以及 requestVote 
如何判定 多数人同意选举成功
如何解决选举竞争问题




